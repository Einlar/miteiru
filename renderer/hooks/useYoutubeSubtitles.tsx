import { useState, useCallback } from 'react';

export interface YoutubeSubtitleOption {
  language: string;
  name: string;
  isAutoGenerated?: boolean;
}

export interface YoutubeSubtitlesState {
  subtitles: YoutubeSubtitleOption[];
  isLoading: boolean;
  error: string | null;
}

export const useYoutubeSubtitles = () => {
  const [state, setState] = useState<YoutubeSubtitlesState>({
    subtitles: [],
    isLoading: false,
    error: null
  });

  // Extract YouTube video ID from URL
  const getYoutubeVideoId = useCallback((url: string): string | null => {
    const patterns = [
      /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
      /^([a-zA-Z0-9_-]{11})$/ // Direct video ID
    ];
    
    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match) return match[1];
    }
    return null;
  }, []);

  // Check if URL is a YouTube URL
  const isYoutubeUrl = useCallback((url: string): boolean => {
    return getYoutubeVideoId(url) !== null;
  }, [getYoutubeVideoId]);

  // Fetch available YouTube subtitles for a video
  const fetchAvailableSubtitles = useCallback(async (videoUrl: string) => {
    const videoId = getYoutubeVideoId(videoUrl);
    
    if (!videoId) {
      setState(prev => ({ ...prev, error: 'Invalid YouTube URL' }));
      return;
    }

    setState(prev => ({ ...prev, isLoading: true, error: null, subtitles: [] }));

    try {
      console.log(`[useYoutubeSubtitles] Fetching available subtitles for ${videoId}`);
      
      // Use our new yt-dlp based subtitle listing
      const result = await window.ipc.invoke('getYoutubeSubtitleLanguages', videoId);
      
      if (result && result.languages) {
        const availableSubtitles: YoutubeSubtitleOption[] = result.languages.map((lang: any) => ({
          language: lang.code,
          name: lang.name || lang.code.toUpperCase(),
          isAutoGenerated: lang.isAutoGenerated || false
        }));

        console.log(`[useYoutubeSubtitles] Found ${availableSubtitles.length} subtitles:`, availableSubtitles);
        
        setState(prev => ({ 
          ...prev, 
          subtitles: availableSubtitles,
          isLoading: false 
        }));
      } else {
        throw new Error('No subtitle data received from yt-dlp');
      }
    } catch (error) {
      console.error('[useYoutubeSubtitles] Error fetching YouTube subtitles:', error);
      setState(prev => ({ 
        ...prev, 
        error: error.message || 'Failed to fetch YouTube subtitles',
        isLoading: false 
      }));
    }
  }, [getYoutubeVideoId]);

  // Fetch specific subtitle content
  const fetchSubtitleContent = useCallback(async (videoUrl: string, language: string) => {
    const videoId = getYoutubeVideoId(videoUrl);
    
    if (!videoId) {
      throw new Error('Invalid YouTube URL');
    }

    console.log(`[useYoutubeSubtitles] Fetching ${language} subtitle content for ${videoId}`);
    
    try {
      // Use our updated getYoutubeSubtitle with better language matching
      const entries = await window.ipc.invoke('getYoutubeSubtitle', videoId, language);
      
      if (!entries || entries.length === 0) {
        throw new Error(`No subtitle entries found for ${language}`);
      }
      
      console.log(`[useYoutubeSubtitles] Successfully fetched ${entries.length} subtitle entries for ${language}`);
      return entries;
    } catch (error) {
      console.error(`[useYoutubeSubtitles] Error fetching ${language} subtitle content:`, error);
      throw error;
    }
  }, [getYoutubeVideoId]);

  // Clear current state
  const clearSubtitles = useCallback(() => {
    setState({
      subtitles: [],
      isLoading: false,
      error: null
    });
  }, []);

  return {
    ...state,
    getYoutubeVideoId,
    isYoutubeUrl,
    fetchAvailableSubtitles,
    fetchSubtitleContent,
    clearSubtitles
  };
};
